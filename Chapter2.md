## 进制转换

* 16进制转2进制：每4位二进制转换1位16进制，若二进制位总数不是4的倍数，前面用0补足
* $2^n(n\ge0)$转16进制：将$n$表示成$i+4j（0\le i\le 3）$的形式，则转换后的16进制为0X $2^i$+$j$个0

## 字节顺序

排列一个对象的字节有2个通用的方法：

* 大端法：最高有效字节在前面
* 小端法：最低有效字节在前面

对于16进制数0X1234567，其字节排列顺序如下图所示：

![image-20200527215642561](res/image-20200527215642561.png)

## 位级运算

* 利用异或交换2个值(不使用中间值)

	```c
	void inplace_swap(int *x,int *y)
	{
	    *y = *x ^ *y;
	    *x = *x ^ *y;
	    *y = *x ^ *y
	}
	```

* 左移：丢弃最高的$k$位，并在右端补$k$个0

* 逻辑右移：在左端补$k$个0（用于无符号数）

* 算数右移：在左端补$k$个最高有效位（即符号位）的值（用于无符号数）

* 对于一个由$w$位组成的数据类型，若$k\ge w$，则实际移位量通过计算$k \bmod w$得到（保持位移量小于待移位值的位数）

## 整数表示

### 无符号数的编码

$B2U_w(x)=\sum_{i=0}^{w-1}x_i2^i$

### 有符号数的编码

* 补码：$B2T_w(x)=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i$
* 反码：$B2O_w(x)=-x_{w-1}(2^{w-1}-1)+\sum_{i=0}^{w-2}x_i2^i$
* 原码：$B2S_w(x)=(-1)^{x_{w-1}}\cdot(\sum_{i=0}^{w-2}x_i2^i) $
* 原码和反码对数字0有2种不同的编码方式，把$[000\cdots 0]$解释为$+0$，原码中$-0$表示为$[100\cdots 0]$，在反码中$-0$表示为$[111\cdots 1]$

### 类型转换

* 强制类型转换的结果保持位值不变，只是改变了解释这些位的方式
* 当执行一个运算时，如果它的一个运算是有符号的而另一个是无符号的，那么C语言会隐式的将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算

### 扩展

* 无符号数的零扩展：要将一个无符号数转换为一个更大的数据类型，只要简单地在表示地开头添加0，这种运算被称为0扩展
* 补码数的符号扩展：要将一个补码数字转换为一个更大的数据类型，可以执行一个符号扩展，在表示中添加最高有效位的值

### 截断

把$x$截断为$k$位的$x'$

* 无符号数的截断：$x'=x\bmod 2^k$
* 无符号数的截断：用补码计算$k$位的$x'$

### 溢出

* 无符号加法中的溢出：对在范围$0\le x,y\le UMax_w$中的$x$和$y$，令$s=x+y$，当且仅当$s<x$（或者等价地$s<y$）时，发生了溢出

* 补码加法中地溢出：对满足$TMin_w\le x,y\le TMax_w$的$x$和$y$，令$s=x+y$，当且仅当$x>0,y>0$，但$s\le 0$时，计算$s$发生了正溢出。当且仅当$x<0,y<0$，但$s\ge 0$时，计算$s$发生了负溢出

	>补码的加法形成了一个阿贝尔群，总会有$(x+y)-y=x$

### 补码的非

$$
\lnot x=
\begin{cases}
TMin,	x=TMin\\
-x,	x>TMin
\end{cases}
$$



1. 对每一位求补，再对结果加1
2. 假设$k$是最右边的1的位置，因而$x$的位级表示形如$[x_{w-1},x_{w-2},\cdots,x_{k+1},0,\cdots,0]$。（只要$x\ne 0$就能找到这样的$k$。）这个值的非携程二进制格式就是$[\lnot x_{w-1},\lnot x_{w-2},\cdots,\lnot x_{k-1},1,0,\cdots,0]$，也就是说，我们对位$k$左边的所有位取反